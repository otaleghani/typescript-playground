// anonymous object
function greet0(person: { name: string, age: number }) {
  return "Hello " + person.name;
}

// named object
interface Person {
  name: string;
  age: number;
}
function greet1(person: Person) {
  return "Hello " + person.name;
}

// type alias
type PersonType = {
  name: string;
  age: number;
}
function greet2(person: PersonType) {
  return "Hello " + person.name;
}

// optional properties
interface PaintOptions {
  shape: string;
  xPos?: number;
  yPos?: number;
}

// You'll need guard clause
function paintShape(opts: PaintOptions) {
  let xPos = opts.xPos === undefined ? 0 : opts.xPos
  let yPos = opts.yPos === undefined ? 0 : opts.yPos
  console.log(opts.shape, xPos, yPos)
}

// Can also be done with default values
function paintShape2({ shape, xPos = 0, yPos = 0 }:PaintOptions) {
  console.log(shape, xPos, yPos)
}


// readonly creates an immutable value. but it's content can be changed
interface SomeType {
  readonly prop: string;
  readonly data: { name: string; age: number };
}
function doSomething0(obj: SomeType) {
  // obj.prop = "Helo" // Will cause an error
  obj.data.age++
  obj.data.name = "helo"
}

// You can make a readonly value editable by aliasing it
interface Person {
  name: string;
  age: number;
}
interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}

let writablePerson: Person = {
  name: "Person",
  age: 42,
}
// This is basically an alias, so you are modifying readonlyPerson throgh writablePerson
let readonlyPerson: ReadonlyPerson = writablePerson;

console.log(readonlyPerson.age)
writablePerson.age++
console.log(readonlyPerson.age)

// this is a index signature
// basically is used when you don't know what keys an object has
interface Dict {
  [index: string]: number;
}

const asd: Dict = {
  sandro: "sandro",
  alberto: "alberto",
}
